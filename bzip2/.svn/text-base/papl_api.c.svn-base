#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <string.h> 	// memcpy

#include <sys/types.h>
#include <sys/wait.h>	// waitpid

#include <fcntl.h>		// for mmap
#include <errno.h>
#include <sys/mman.h>

//#include "papl.h"
#include "papl_queue.h"

#define merge_table(a, b) merge_table[a * merge_table_row + b]
#define scan_table(a, b) scan_table[a * scan_table_row + b]

#define SCANNER	0
#define p_num		(WORKERS + 1)

int err_detect (unsigned int index, long *scan_table, long *merge_table ) {
	if( scan_table((index+1), 1) != merge_table(index,0) ) {
		if( scan_table((index+1), 1) != -1 ) {
			printf("ERROR !!!! block: %d\n", index);
			//printf("%d\t%8ld\t%8ld\t%d\n",
					//index,
					//scan_table((index+1), 1)
					//,merge_table(index, 0)
					//,scan_table((index+1),1) - merge_table(index,0));
		}
	}
	return 0;
}


void papl_exec() {
	pid_t pid[p_num];
	int i, offset, process_num;
	long pos, file_size;
	unsigned int index, len;

	/* Get file size */ 
	if( papl.fp == NULL ) {
		printf("input open\n");
		papl.fp = fopen(papl.input, "rb");
	}
	fseek(papl.fp, 0L, SEEK_END);
	file_size = ftell(papl.fp);
	rewind(papl.fp);

	/* shared memory */
	char *mem;
	long *scan_table;
	//long *merge_table;

	//mem = malloc(obuf_size);
	mem = malloc(0x8000);

	//mem = mmap(0, mem_len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	//if (mem == MAP_FAILED) fprintf(stderr, "  mmap mem failed: %s\n", strerror(errno));

	scan_table = mmap(0, scan_table_len * sizeof(long), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	if (scan_table == MAP_FAILED) fprintf(stderr, "  mmap scan table failed: %s\n", strerror(errno));


	//merge_table = mmap(0, merge_table_len * sizeof(long), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	//if (merge_table == MAP_FAILED) fprintf(stderr, "  mmap merge table failed: %s\n", strerror(errno));

	memset( scan_table, 0, scan_table_len * sizeof(long) );
	//memset( merge_table, 0, merge_table_len * sizeof(long) );

	papl_createQueue(WORKERS);
	index = offset = 0;

	long ttime;

	process_num = 0;
create_process:
	switch (pid[process_num] = fork()) {
		case -1:
			fprintf(stderr, "  ERROR @ fork\n");
			exit(-1);

		case 0:
			switch (process_num) {
				case SCANNER:		// scanning
					pt1("@@@@ Scanner(%d) created\n", getpid());

					get_time();
					index = papl.scan( papl.fp, scan_table );

					//printf("scanner: ");
					print_time(ttime);
					//fclose(papl.fp);

					for(i=0; i<WORKERS; i++, index++)
						scan_table(index, 0) = -1;

					//for(i=0;i<index; i++)
						//printf("%d\t%ld\t%ld\n", i, scan_table(i,0), scan_table(i,1));

					pt0("@@@@ Scanner process exit\n");
					exit(0);

				default:	// do_work
					pt2("@@@@ Worker%d(%d) created\n", process_num, getpid());

					papl.fp = fopen(papl.input, "rb");

					index = process_num - 1;
					for(;;) {
						pos = scan_table(index, 0);
						if( pos > 0 ) {
worker:
							pt3("  @@ Worker %d: scan_table[%3d]: %8ld\n", process_num, index, pos);
							//printf("  @@ Worker %d: scan_table[%3d]: %8ld\n", process_num, index, pos);
							len = papl.do_work(index, scan_table, process_num - 1);

							//merge_table(index, 1) = papl.total_in;
							//merge_table(index, 0) = len;	// flag to end of block
							//printf("  len %d: %u\n", process_num, len);

							pt5("  @@ Worker%3d commit at row %3d: %3d\t%8u\t%8u\n", process_num, index/chunk_size, index, papl.total_in, len);
							//printf("  @@ Worker%3d commit at row %3d: %3d\t%8u\t%8u\n", process_num, index/chunk_size, index, papl.total_in, len);
							index += WORKERS;
						}
						else if( pos == 0 && index == 0) goto worker;
						else if( pos == -1 || pos == file_size ) break;
						else usleep(1);
					}
					produce_end(-2, process_num - 1);

					fclose(papl.fp);
			}
			pt1("@@@@ Work process exit %d\n", process_num);
			exit(0);

		default:		// Merge
			process_num++;
			if (process_num < p_num ) goto create_process;
			/* Create p_num of processes */

			//if( papl.ofp == NULL) {
				//pt0("output open\n");
				papl.ofp = fopen(papl.output,"wb");
			//}

			index = 0;
			for(;;) {
				len = (unsigned int) consume_chunk(mem, index);

				if( len == -2 ) break;
				if( len == -1 ) {
					index++;
					if(index == WORKERS) index = 0;
					continue;
				} else {
					fwrite(mem, sizeof(char), len, papl.ofp);
					pt2("    @@@@ fwrite %d %u\n", index, len);
					//printf("    @@@@ fwrite %d %u\n", index, len);
				}
			}
	}

	for(i=0; i<p_num; i++) {
		waitpid( pid[i], NULL, 0);
		pt1("pid[%d] joined\n", i);
	}

	/* munmap */
	free(mem);
	//if( munmap(mem, mem_len) )
		//fprintf(stderr, " munmap mem failed: %s\n", strerror(errno));
	if( munmap(scan_table, scan_table_len * sizeof(long)) )
		fprintf(stderr, " munmap scan_table failed: %s\n", strerror(errno));
	//if( munmap(merge_table, merge_table_len * sizeof(long) ) )
		//fprintf(stderr, " munmap merge_table failed: %s\n", strerror(errno));
	papl_destroyQueue(WORKERS);
}

